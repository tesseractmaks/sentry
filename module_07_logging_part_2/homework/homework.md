## 1

Мы подготовили для вас небольшой приложение, которое по сути является консольным калькулятором для двух чисел. И вот незадача, забыли сделать нормальное логирование. Пока же там есть только принты.

Создайте логер в каждом модуле и добавьте вместо вызова print логирование с подходящим по смыслу уровнем.


## 2

К приложению из задания выше добавьте функцию, которая будет конфигурировать логгирование через ООП подход: конфигурацию хэндлера для консоли (стандартвый выход). Так же добавьте форматтер вида ко всем обработчикам: 

```уровень | логгер | время | строка | сообщение ```


## 3

Иногда, особенно когда логов много, может быть неудобно смотреть большой файл с мешаниной записей. Давайте чуть-чуть наведем тут порядка. Добавьте хэндлер, который в зависимости от уровня сообщения будет писать их в разные файлы. То есть все сообщения с уровнем дебаг попадут в файл только для сообщений такого уровня и тд. Не забудьте добавить инициализацию нового хэндлера в функцию из предыдущего задания.

## 4

Как мы видим, функция конфигурирования уже весьма прилично разрослась и выглядит не слишком опрятно. Перепишите ее на декларативный манер и вынесите ее в отдельный файл. А в функции просто применяйте конфигурацию. 

## 5

Теперь, когда мы знаем логирование очень хорошо, самое время исправить недочеты в приложении из первого урока.  Добавьте туда: 
декларативное конфигурирование логирования.
логгер utils должен писать все сообщения уровня инфо и выше так же в файл, и мы хотим хранить записи только за последние 10 часов.
убедитесь, что у аутпуте нет записей от других логгеров (urllib).


## 6

Иногда разобраться в хитрой иерархии логгеров бывает затруднительно. Специально для таких целей добрые люди написали библиотеку: она выводит древовидную структуру всех существующих логгеров. https://pypi.org/project/logging_tree/
Воспользуйтесь ей: запустите и посмотрите, как выглядит каждый logger из приложений, что мы только что разобрали. 


## 7

Мы намеренно не рассмотрели как реализованы и как пользоваться объектами Filter в логировании python. Причин тут две: это не такая частая задача а также это отличный повод для практики в работе с документацией. 

  Итак, задание: прочитайте документацию об объекте Filter
https://docs.python.org/3/library/logging.html#filter-objects

Реализуйте собственный фильтр, который будет отсеивать сообщения, содержащие не-ascii символы в тексте. Например, такие: ÎŒØ∏‡°⁄·°€йцукен


## 8

Как правило, работая с распределенными приложениями нам приходится решать вопрос с централизованной обработкой логов. Реализуйте: 
обработчик, который будет отправлять логи на некоторый сервер
реализуйте сервер, который будет принимать логи от сервисов
тесты на все это дело

Подсказка: вспомните утилиту командной строки curl и способ запускать такие утилиты из кода на питоне. Например: 

`curl -X POST http://example.com --data "test"`


## 9

Когда вам придется работать в проекте не с нуля, высока вероятность того, что логирование в нем будет сконфигурованно не через python-dict, а через ini-конфигурационный файл. Так что хорошо бы научиться в нем ориентироваться. Он устроен не очень сложно, и если немного поизучать приведенный пример, то станет понятно.

Перепишите конфиг файл, что мы приложили в python-dict, в таком формате. Инициировать логгер через такой файл можно, например, так:

`logging.fileConfig('loging_conf.ini')`
